<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NNSOM.plots &mdash; NNSOM 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            NNSOM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NNSOM.html">NNSOM package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">NNSOM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NNSOM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">NNSOM.plots</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for NNSOM.plots</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.som</span> <span class="kn">import</span> <span class="n">SOM</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.widgets</span> <span class="kn">import</span> <span class="n">Button</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1.inset_locator</span> <span class="kn">import</span> <span class="n">inset_axes</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>

<div class="viewcode-block" id="SOMPlots">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots">[docs]</a>
<span class="k">class</span> <span class="nc">SOMPlots</span><span class="p">(</span><span class="n">SOM</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SOMPlots extends the SOM class by adding visualization capabilities to</span>
<span class="sd">    the Self-Organizing Map (SOM). It allows for the graphical representation</span>
<span class="sd">    of the SOM&#39;s structure, the distribution of input data across its neurons,</span>
<span class="sd">    and various other analytical visualizations that aid in the interpretation</span>
<span class="sd">    of the SOM&#39;s behavior and characteristics.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        dimensions (tuple): The dimensions of the SOM grid.</span>

<span class="sd">    Methods:</span>
<span class="sd">        plt_top():</span>
<span class="sd">            Plots the topology of the SOM using hexagonal units.</span>
<span class="sd">        plt_top_num():</span>
<span class="sd">            Plots the topology of the SOM with numbered neurons.</span>
<span class="sd">        hit_hist(x, textFlag):</span>
<span class="sd">            Plots a hit histogram showing how many data points are mapped to each neuron.</span>
<span class="sd">        gray_hist(x, perc):</span>
<span class="sd">            Plots a histogram with neurons colored in shades of gray based on a given percentage value.</span>
<span class="sd">        color_hist(x, avg):</span>
<span class="sd">            Plots a color-coded histogram based on the average values provided for each neuron.</span>
<span class="sd">        cmplx_hit_hist(x, perc_gb, clust, ind_missClass, ind21, ind12):</span>
<span class="sd">            Plots a complex hit histogram showing the distribution of data and misclassifications.</span>
<span class="sd">        plt_nc():</span>
<span class="sd">            Plots the neighborhood connections between the SOM neurons.</span>
<span class="sd">        neuron_dist_plot():</span>
<span class="sd">            Plots the distances between neurons to visualize the SOM&#39;s topology.</span>
<span class="sd">        simple_grid(avg, sizes):</span>
<span class="sd">            Plots a simple hexagonal grid with varying colors and sizes based on provided data.</span>
<span class="sd">        setup_axes():</span>
<span class="sd">            Sets up the axes for plotting individual neuron statistics.</span>
<span class="sd">        plt_dist(dist):</span>
<span class="sd">            Plots distributions of values across the SOM neurons.</span>
<span class="sd">        plt_wgts():</span>
<span class="sd">            Plots the weights of the SOM neurons as line graphs.</span>
<span class="sd">        plt_pie(title, perc, *argv):</span>
<span class="sd">            Plots pie charts for each neuron to show data distribution in categories.</span>
<span class="sd">        plt_histogram(som, data):</span>
<span class="sd">            Plots histograms for each neuron to show the distribution of data.</span>
<span class="sd">        plt_boxplot(data):</span>
<span class="sd">            Plots boxplots for each neuron to show the distribution of data.</span>
<span class="sd">        plt_dispersion_fan_plot(data):</span>
<span class="sd">            Plots dispersion or fan plots for each neuron.</span>
<span class="sd">        plt_violin_plot(som, data):</span>
<span class="sd">            Plots violin plots for each neuron to show the distribution of data.</span>
<span class="sd">        plt_scatter(x, indices, clust, reg_line=True):</span>
<span class="sd">            Plots scatter graphs for each neuron to show the distribution of two variables.</span>
<span class="sd">        multiplot(plot_type, *args):</span>
<span class="sd">            Facilitates plotting of multiple types of graphs based on the plot_type argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>

<div class="viewcode-block" id="SOMPlots.plt_top">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_top">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Plots the topology of the SOM using hexagonal units.</span>

<span class="sd">        Args:</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, pathces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="n">shapex</span><span class="p">,</span> <span class="n">shapey</span> <span class="o">=</span> <span class="n">get_hexagon_shape</span><span class="p">()</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">temp</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
                            <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="c1"># Assign the cluster number for each hexagon</span>
        <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="p">{</span><span class="nb">hex</span><span class="p">:</span> <span class="n">neuron</span> <span class="k">for</span> <span class="n">neuron</span><span class="p">,</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">patches</span><span class="p">)}</span>

        <span class="c1"># Mouse Click Functionality</span>
        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Get rid of extra white space on sides</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span></div>


<div class="viewcode-block" id="SOMPlots.plt_top_num">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_top_num">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_top_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Plots the topology of the SOM with numbered neurons.</span>

<span class="sd">        Args:</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, pathces, text</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="n">shapex</span><span class="p">,</span> <span class="n">shapey</span> <span class="o">=</span> <span class="n">get_hexagon_shape</span><span class="p">()</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">temp</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
                            <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="c1"># Assign the cluster number for each hexagon</span>
        <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="p">{</span><span class="nb">hex</span><span class="p">:</span> <span class="n">neuron</span> <span class="k">for</span> <span class="n">neuron</span><span class="p">,</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">patches</span><span class="p">)}</span>

        <span class="n">text</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">_fontproperties</span><span class="o">.</span><span class="n">_weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">_fontproperties</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="mf">12.0</span>
            <span class="n">text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="c1"># Mouse Click Functionality</span>
        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Get rid of extra white space on sides</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span></div>


<div class="viewcode-block" id="SOMPlots.hit_hist">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.hit_hist">[docs]</a>
    <span class="k">def</span> <span class="nf">hit_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">textFlag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate Hit Histogram</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: array-like</span>
<span class="sd">            The input data to be clustered</span>
<span class="sd">        textFlag: bool</span>
<span class="sd">            If true, the number of members of each cluster is printed on the cluster.</span>
<span class="sd">        mouse_click: bool</span>
<span class="sd">            If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">        connect_pick_event</span>
<span class="sd">            If true, the pick event is connected to the plot</span>
<span class="sd">        kwargs: dict</span>
<span class="sd">            Additional arguments to be passed to the on_pick function</span>
<span class="sd">            Possible keys includes:</span>
<span class="sd">            &#39;data&#39;, &#39;labels&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;,</span>
<span class="sd">            &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            fig, ax, patches, text</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Determine the shape of the hexagon to represent each cluster</span>
        <span class="n">shapex</span><span class="p">,</span> <span class="n">shapey</span> <span class="o">=</span> <span class="n">get_hexagon_shape</span><span class="p">()</span>

        <span class="c1"># Create the main figure and axes</span>
        <span class="c1"># Set the main axes properties</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="c1"># Create the cluster hexagons</span>
        <span class="n">hexagons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="nb">hex</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span>
                             <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
                             <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">hexagons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">hex</span><span class="p">)</span>

        <span class="c1"># Assign cluster number for each hexagon</span>
        <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="p">{</span><span class="nb">hex</span><span class="p">:</span> <span class="n">neuron</span> <span class="k">for</span> <span class="n">neuron</span><span class="p">,</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hexagons</span><span class="p">)}</span>

        <span class="c1"># Plot the inner hexagon</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="c1"># Add the size of the cluster, if needed</span>
        <span class="n">text</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">textFlag</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="s1">&#39;9&#39;</span><span class="p">,</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">_fontproperties</span><span class="o">.</span><span class="n">_weight</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">_fontproperties</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="mf">12.0</span>
                <span class="n">text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="c1"># Compute the SOM outputs for the data set</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_flag</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_func</span><span class="p">)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_som</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">outputs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span>

        <span class="c1"># Find out how many inputs fall into each cluster</span>
        <span class="n">hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">norm_hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hits</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">hits</span><span class="p">))</span>

        <span class="n">shapex1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapex</span><span class="p">,</span> <span class="n">shapex</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">shapey1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapey</span><span class="p">,</span> <span class="n">shapey</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Make the size of the inner hexagon proportional to the cluster size</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_facecolor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_edgecolor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex1</span> <span class="o">*</span> <span class="n">norm_hits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey1</span> <span class="o">*</span> <span class="n">norm_hits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">textFlag</span><span class="p">:</span>
                <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hits</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># Get rid of extra white space on sides</span>
        <span class="c1"># plt.axis(&#39;off&#39;)</span>
        <span class="c1">#fig.tight_layout()</span>

        <span class="c1"># Mouse Click Functionality</span>
        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span></div>


<div class="viewcode-block" id="SOMPlots.gray_hist">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.gray_hist">[docs]</a>
    <span class="k">def</span> <span class="nf">gray_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">perc</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Make another hit histogram figure, and change the colors of the hexagons</span>
        <span class="c1"># to indicate the perc of pdb (or gb) ligands in each cluster. Lighter color</span>
        <span class="c1"># means more PDB ligands, darker color means more well-docked bad binders.</span>

        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>
        <span class="n">dmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">perc</span><span class="p">))</span>    <span class="c1"># Find the maximum value of perc across all clusters</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hit_hist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mouse_click</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Scale the gray scale to the perc value</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">perc</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">/</span> <span class="n">dmax</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="n">scale</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>  <span class="c1"># Create a gray color based on the scaled value</span>
            <span class="n">color</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># Add alpha value</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_facecolor</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>  <span class="c1"># Apply the color to the patch</span>

        <span class="c1"># Get rid of extra white space on sides</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span></div>


<div class="viewcode-block" id="SOMPlots.color_hist">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.color_hist">[docs]</a>
    <span class="k">def</span> <span class="nf">color_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Plot an SOM figure where the size of the hexagons is related to</span>
        <span class="c1"># the number of elements in the clusters, and the color of the</span>
        <span class="c1"># inner hexagon is coded to the variable avg, which could be the</span>
        <span class="c1"># average number of a certain type of bond in the cluster</span>

        <span class="c1"># Find the maximum value of avg across all clusters</span>
        <span class="n">dmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">avg</span><span class="p">))</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hit_hist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">mouse_click</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Use the jet color map</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">)</span>

        <span class="c1"># Adjust the color of the hexagon according to the avg value</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">xx</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">/</span> <span class="n">dmax</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_facecolor</span> <span class="o">=</span> <span class="n">color</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="c1"># # Add a color bar the the figure to indicate levels</span>
        <span class="c1"># # create an axes on the right side of ax. The width of cax will be 5%</span>
        <span class="c1"># # of ax and the padding between cax and ax will be fixed at 0.05 inch.</span>
        <span class="c1"># divider = make_axes_locatable(ax)</span>
        <span class="c1"># cax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)</span>
        <span class="c1">#</span>
        <span class="c1"># cbar = plt.colorbar(ax, cax=cax, cmap=cmap)</span>

        <span class="n">cax</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">cax</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="c1"># Adjust the tick labels to the correct scale</span>
        <span class="n">ticklab</span> <span class="o">=</span> <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticks</span><span class="p">()</span>
        <span class="n">numticks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ticklab</span><span class="p">)</span>
        <span class="n">ticktext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numticks</span><span class="p">):</span>
            <span class="n">ticktext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dmax</span> <span class="o">*</span> <span class="n">ticklab</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># Set the ticks first</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticklab</span><span class="p">)</span>

        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">ticktext</span><span class="p">)</span>

        <span class="c1"># Get rid of extra white space on sides</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">cbar</span></div>


<div class="viewcode-block" id="SOMPlots.cmplx_hit_hist">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.cmplx_hit_hist">[docs]</a>
    <span class="k">def</span> <span class="nf">cmplx_hit_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">clust</span><span class="p">,</span> <span class="n">perc</span><span class="p">,</span> <span class="n">ind_missClass</span><span class="p">,</span> <span class="n">ind21</span><span class="p">,</span> <span class="n">ind12</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generates a complex hit histogram.</span>
<span class="sd">        It indicates what the majority class in each cluster is, and how many specific class occur in each cluster.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: array-like</span>
<span class="sd">                The input data to be clustered</span>
<span class="sd">            clust: list</span>
<span class="sd">                List of indices of inputs that belong in each cluster</span>
<span class="sd">            perc: array-like</span>
<span class="sd">                Percent of the specific class in each cluster</span>
<span class="sd">            ind_missClass: array-like</span>
<span class="sd">                Indices of consistently misclassified inputs</span>
<span class="sd">            ind21: array-like</span>
<span class="sd">                Indices of false positive cases</span>
<span class="sd">            ind12: array-like</span>
<span class="sd">                Indices of false negative cases</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="k">if</span> <span class="n">mouse_click</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clust</span>

        <span class="c1"># Make hit histogram</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hit_hist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mouse_click</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>

            <span class="c1"># Make face color green if majority of class in cluster are good binders</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">perc</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">):</span>
                <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_facecolor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">ind_missClass</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># If there are errors in the cluster, change width of</span>
                <span class="c1"># hexagon edge in proportion to number of errors</span>
                <span class="n">lwidth</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">ind_missClass</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">ind12</span><span class="p">))</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">ind21</span><span class="p">)):</span>
                    <span class="c1"># Make edge color red if most errors are false positive</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Make edge color purple if most errors are false negative</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lwidth</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_linewidth</span> <span class="o">=</span> <span class="n">lwidth</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_edgecolor</span> <span class="o">=</span> <span class="n">color</span>

        <span class="c1"># Get rid of extra white space on sides</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span></div>


<div class="viewcode-block" id="SOMPlots.custom_cmplx_hit_hist">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.custom_cmplx_hit_hist">[docs]</a>
    <span class="k">def</span> <span class="nf">custom_cmplx_hit_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">face_labels</span><span class="p">,</span> <span class="n">edge_labels</span><span class="p">,</span> <span class="n">edge_width</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate cmplex hit hist</span>
<span class="sd">        Users can specify the face color, edge width and edge color for each neuron.</span>

<span class="sd">        x: array-like or sequence of vectors</span>
<span class="sd">            The input data to be clustered</span>
<span class="sd">        face_labels: array-like</span>
<span class="sd">            class labels to determine the face color of the hexagons</span>
<span class="sd">        edge_labels: array-like</span>
<span class="sd">            class labels to determine the edge color of the hexagons</span>
<span class="sd">        edge_width: array-like</span>
<span class="sd">            A list of edge_width standerdised between (1 - 20).</span>
<span class="sd">            You can call get_edge_width to get the standardised edge width in the utils function.</span>
<span class="sd">            len(edge_width) must be equal to the number of neurons</span>
<span class="sd">        mouse_click: bool</span>
<span class="sd">            If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">        kwargs: dict</span>
<span class="sd">            Additional arguments to be passed to the onpick function</span>
<span class="sd">            Possible keys include:</span>
<span class="sd">            &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;,</span>
<span class="sd">            &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, patches, text</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">face_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">face_labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edge_labels</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">edge_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edge_width</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Check if the input data is a sequence of vectors</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be a 2D array&quot;</span><span class="p">)</span>

        <span class="c1"># Check if the input data can be cdist with self.w</span>
        <span class="c1"># the input data must be transposed</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input data must have the same number of features as the SOM&quot;</span><span class="p">)</span>

        <span class="c1"># Check if the face color, line width and edge color are 1D arrays</span>
        <span class="k">if</span> <span class="n">face_labels</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">edge_width</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">edge_labels</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fcolor, lwidth and ecolor must be 1D arrays&quot;</span><span class="p">)</span>

        <span class="c1"># Check if the length of fcolor, lwidth and ecolor are equal to the number of neurons</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numNeurons</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_width</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numNeurons</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numNeurons</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of x, fcolor, lwidth and ecolor must be equal to the number of neurons&quot;</span><span class="p">)</span>

        <span class="c1"># Make hit histogram</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hit_hist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">mouse_click</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Exclude nan values for the unique color count</span>
        <span class="n">unique_fcolor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">face_labels</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">face_labels</span><span class="p">)])</span>
        <span class="n">unique_ecolor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edge_labels</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">edge_labels</span><span class="p">)])</span>

        <span class="c1"># Create the colormaps</span>
        <span class="n">cmap1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_fcolor</span><span class="p">))</span>
        <span class="n">cmap2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;cool&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_ecolor</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">face_labels</span><span class="p">[</span><span class="n">neuron</span><span class="p">]):</span>
                <span class="c1"># Normalize the class label to the colormap index</span>
                <span class="n">color1_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">unique_fcolor</span> <span class="o">==</span> <span class="n">face_labels</span><span class="p">[</span><span class="n">neuron</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_fcolor</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">color2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">unique_ecolor</span> <span class="o">==</span> <span class="n">edge_labels</span><span class="p">[</span><span class="n">neuron</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_ecolor</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Get the corresponding color from the colormap</span>
                <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_facecolor</span> <span class="o">=</span> <span class="n">cmap1</span><span class="p">(</span><span class="n">color1_idx</span><span class="p">)</span>
                <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_linewidth</span> <span class="o">=</span> <span class="n">edge_width</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span>
                <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_edgecolor</span> <span class="o">=</span> <span class="n">cmap2</span><span class="p">(</span><span class="n">color2_idx</span><span class="p">)</span>

        <span class="c1"># Get rid of extra white space on sides</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span></div>


<div class="viewcode-block" id="SOMPlots.plt_nc">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_nc">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_nc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generates neighborhood connection map.</span>
<span class="sd">        The gray hexagons represent cluster centers.</span>

<span class="sd">        Args:</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, pathces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Neighborhood Connection Map. The gray hexagons represent cluster centers.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Determine the hexagon shape</span>
        <span class="n">shapex</span><span class="p">,</span> <span class="n">shapey</span> <span class="o">=</span> <span class="n">get_hexagon_shape</span><span class="p">()</span>
        <span class="n">shapex</span><span class="p">,</span> <span class="n">shapey</span> <span class="o">=</span> <span class="n">shapex</span> <span class="o">*</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">shapey</span> <span class="o">*</span> <span class="mf">0.3</span>

        <span class="c1"># Determine the elongated hexagon shape</span>
        <span class="n">edgex</span><span class="p">,</span> <span class="n">edgey</span> <span class="o">=</span> <span class="n">get_edge_shape</span><span class="p">()</span>

        <span class="c1"># Set up edges</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numNeurons</span><span class="p">,</span> <span class="n">numNeurons</span><span class="p">))</span>
        <span class="n">neighbors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_dist</span> <span class="o">&lt;=</span> <span class="mf">1.001</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">neighbors</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">))</span>

        <span class="c1"># Get the figure and axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="c1"># Draw elongated hexagons between neurons</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">pdiff</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">pdiff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pdiff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span> <span class="o">=</span> <span class="n">rotate_xy</span><span class="p">(</span><span class="n">edgex</span><span class="p">,</span> <span class="n">edgey</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
                <span class="n">edgePos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">edgePos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ex</span><span class="p">,</span> <span class="n">edgePos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">))</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Setup neurons. Place gray hexagon at neuron locations.</span>
        <span class="n">hexagons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="nb">hex</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
                           <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">hexagons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">hex</span><span class="p">)</span>

        <span class="c1"># Assign the cluster number for each hexagon</span>
        <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="p">{</span><span class="nb">hex</span><span class="p">:</span> <span class="n">neuron</span> <span class="k">for</span> <span class="n">neuron</span><span class="p">,</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hexagons</span><span class="p">)}</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span></div>


<div class="viewcode-block" id="SOMPlots.neuron_dist_plot">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.neuron_dist_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">neuron_dist_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generates distance map.</span>
<span class="sd">        The gray hexagons represent cluster centers.</span>
<span class="sd">        The colors of the elongated hexagons between the cluster centers represent the distance between the centers.</span>
<span class="sd">        The darker the color the larget the distance.</span>

<span class="sd">        Args:</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>
<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, pathces, text</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Determine the shape of the hexagon to represent each cluster</span>
        <span class="n">symmetry</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
        <span class="n">shapex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">shapey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">z</span>
        <span class="n">edgex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">edgey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">z</span>
        <span class="n">shapex</span> <span class="o">=</span> <span class="n">shapex</span> <span class="o">*</span> <span class="mf">0.3</span>
        <span class="n">shapey</span> <span class="o">=</span> <span class="n">shapey</span> <span class="o">*</span> <span class="mf">0.3</span>

        <span class="c1"># Set up edges</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numNeurons</span><span class="p">,</span> <span class="n">numNeurons</span><span class="p">))</span>
        <span class="n">neighbors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_dist</span> <span class="o">&lt;=</span> <span class="mf">1.001</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">neighbors</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">))</span>

        <span class="c1"># Get the figure, remove the frame, and find the limits</span>
        <span class="c1"># of the axis that will fit hexagons</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="c1"># Draw elongated hexagons between neurons</span>
        <span class="n">numEdges</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">pdiff</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">pos</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">pdiff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pdiff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span> <span class="o">=</span> <span class="n">rotate_xy</span><span class="p">(</span><span class="n">edgex</span><span class="p">,</span> <span class="n">edgey</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
                <span class="n">edgePos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">edgePos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">ex</span><span class="p">,</span> <span class="n">edgePos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Setup neurons. Place gray hexagon at neuron locations.</span>
        <span class="n">hexagons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="nb">hex</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">),</span>
                           <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">hexagons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">hex</span><span class="p">)</span>

        <span class="c1"># Assign the cluster number for each hexagon</span>
        <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="p">{</span><span class="nb">hex</span><span class="p">:</span> <span class="n">neuron</span> <span class="k">for</span> <span class="n">neuron</span><span class="p">,</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hexagons</span><span class="p">)}</span>

        <span class="c1"># Find the distance between neighboring weights.</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numEdges</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">levels</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mx</span> <span class="o">==</span> <span class="n">mn</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numEdges</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="p">(</span><span class="n">levels</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mx</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span>

        <span class="c1"># Make the face color black for the maximum distance and</span>
        <span class="c1"># yellow for the minimum distance. The middle distance  will</span>
        <span class="c1"># be red.</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">levels</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">([</span><span class="n">level</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">green</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">([</span><span class="n">level</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="n">patches</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_facecolor</span> <span class="o">=</span> <span class="n">c</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Mouse Click Functionality</span>
        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span></div>


<div class="viewcode-block" id="SOMPlots.simple_grid">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.simple_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">simple_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Basic hexagon grid plot</span>
<span class="sd">        Colors are selected from avg array.</span>
<span class="sd">        Sizes of inner hexagons are selected rom sizes array.</span>

<span class="sd">        Args:</span>
<span class="sd">            avg: array-like</span>
<span class="sd">                Average values for each neuron</span>
<span class="sd">            sizes: array-like</span>
<span class="sd">                Sizes of inner hexagons</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, pathces, cbar</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Determine the shape of the hexagon to represent each cluster</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span>
        <span class="n">shapex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">shapey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Get the figure, remove the frame, and find the limits</span>
        <span class="c1"># of the axis that will fit all of the hexagons</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="c1"># Draw the outer hexagons</span>
        <span class="n">hexagons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="nb">hex</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span>
                           <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">hexagons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">hex</span><span class="p">)</span>

        <span class="c1"># Assign the cluster number for each hexagon</span>
        <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="p">{</span><span class="nb">hex</span><span class="p">:</span> <span class="n">neuron</span> <span class="k">for</span> <span class="n">neuron</span><span class="p">,</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hexagons</span><span class="p">)}</span>

        <span class="c1"># Plot the inner hexagon</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="n">shapex1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapex</span><span class="p">,</span> <span class="n">shapex</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">shapey1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapey</span><span class="p">,</span> <span class="n">shapey</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Make the size of the inner hexagon proportional to the desired size</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sizes</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">sizes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_facecolor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_edgecolor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex1</span> <span class="o">*</span> <span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">_vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey1</span> <span class="o">*</span> <span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Find the maximum value of avg across all clusters</span>
        <span class="c1"># dmax = np.amax(np.abs(avg))</span>
        <span class="n">dmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span>
        <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span>
        <span class="n">drange</span> <span class="o">=</span> <span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span>

        <span class="c1"># Use the jet color map</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">)</span>

        <span class="c1"># Adjust the color of the hexagon according to the avg value</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="c1">#        xx[neuron] = avg[neuron] / dmax</span>
            <span class="n">xx</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">avg</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">-</span> <span class="n">dmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">drange</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">cmap</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span>
            <span class="n">patches</span><span class="p">[</span><span class="n">neuron</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_facecolor</span> <span class="o">=</span> <span class="n">color</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="c1"># # Add a color bar the the figure to indicate levels</span>
        <span class="c1"># # create an axes on the right side of ax. The width of cax will be 5%</span>
        <span class="c1"># # of ax and the padding between cax and ax will be fixed at 0.05 inch.</span>

        <span class="n">cax</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">cax</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
        <span class="c1"># cbar = fig.colorbar(cax)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">cax</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.046</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>

        <span class="c1"># plt.colorbar(im, fraction=0.046, pad=0.04)</span>
        <span class="c1">#</span>
        <span class="c1"># divider = make_axes_locatable(ax)</span>
        <span class="c1"># cax = divider.append_axes(&quot;right&quot;, size=&quot;5%&quot;, pad=0.05)</span>
        <span class="c1">#</span>
        <span class="c1"># plt.colorbar(im, cax=cax)</span>

        <span class="c1"># Adjust the tick labels to the correct scale</span>
        <span class="n">ticklab</span> <span class="o">=</span> <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticks</span><span class="p">()</span>
        <span class="n">numticks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ticklab</span><span class="p">)</span>
        <span class="n">ticktext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numticks</span><span class="p">):</span>
            <span class="n">ticktext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">drange</span> <span class="o">*</span> <span class="n">ticklab</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dmin</span><span class="p">))</span>

        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticklab</span><span class="p">)</span>

        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">ticktext</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">cbar</span></div>


<div class="viewcode-block" id="SOMPlots.setup_axes">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.setup_axes">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Setup figure, axes and sub-axes for plots</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Determine the hexagon shape</span>
        <span class="n">shapex</span><span class="p">,</span> <span class="n">shapey</span> <span class="o">=</span> <span class="n">get_hexagon_shape</span><span class="p">()</span>
        <span class="n">shminx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">shmaxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">shminy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">shmaxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>

        <span class="c1"># Create the figure and get the transformations from data</span>
        <span class="c1"># to pixel and from pixel to axes.</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                               <span class="n">layout</span><span class="o">=</span><span class="s1">&#39;constrained&#39;</span><span class="p">)</span>

        <span class="c1"># Set the main axes properties</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="c1"># Draw hexagon</span>
        <span class="n">hexagons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="nb">hex</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">neuron</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">neuron</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span>
                           <span class="n">facecolor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">hexagons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">hex</span><span class="p">)</span>

        <span class="c1"># Assign the cluster number for each hexagon</span>
        <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="p">{</span><span class="nb">hex</span><span class="p">:</span> <span class="n">neuron</span> <span class="k">for</span> <span class="n">neuron</span><span class="p">,</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hexagons</span><span class="p">)}</span>

        <span class="c1"># Loop over to create sub-axe in each cluster</span>
        <span class="n">h_axes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">numNeurons</span>   <span class="c1"># A container for sub-axes</span>

        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="c1"># Find the size of the cell in data units</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">neuron</span><span class="p">]</span> <span class="o">+</span> <span class="n">shminx</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">neuron</span><span class="p">]</span> <span class="o">+</span> <span class="n">shmaxx</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">neuron</span><span class="p">]</span> <span class="o">+</span> <span class="n">shminy</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">neuron</span><span class="p">]</span> <span class="o">+</span> <span class="n">shmaxy</span>

            <span class="c1"># Convert the size of the cell to axes units</span>
            <span class="n">minxyDis</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">])</span>
            <span class="n">maxxyDis</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">])</span>
            <span class="n">minxyAx</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">minxyDis</span><span class="p">)</span>
            <span class="n">maxxyAx</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">maxxyDis</span><span class="p">)</span>

            <span class="c1"># Find the width and height of the cell</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">maxxyAx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">minxyAx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">maxxyAx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minxyAx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Find the center point of the cell</span>
            <span class="n">xavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">minxyAx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxxyAx</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">yavg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">minxyAx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">maxxyAx</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># Scale the width and height</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># Just fit-in the hexagon</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">scale</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="n">scale</span>

            <span class="c1"># Locate the beginning point of the cell</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">xavg</span> <span class="o">-</span> <span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">yavg</span> <span class="o">-</span> <span class="p">(</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Create sub-axes</span>
            <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">=</span> <span class="n">inset_axes</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="s1">&#39;100%&#39;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="s1">&#39;100%&#39;</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                        <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span>
                                        <span class="n">bbox_transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">borderpad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[])</span>
            <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span></div>


<div class="viewcode-block" id="SOMPlots.plt_stem">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_stem">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate stem plot for each neuron.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: array-like</span>
<span class="sd">                The x-axis values (align)</span>
<span class="sd">            y: array-like or sequence of vectors</span>
<span class="sd">                The y-axis values (height)</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, h_axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Setup figure, axes, and sub-axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_axes</span><span class="p">()</span>

        <span class="c1"># Draw stem plot</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="c1"># Make graph</span>
            <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;align&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span></div>


<div class="viewcode-block" id="SOMPlots.plt_wgts">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_wgts">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_wgts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate line plot for each neuron.</span>

<span class="sd">        Args:</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, h_axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>

        <span class="c1"># Setup figure, main axes, and sub-axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_axes</span><span class="p">()</span>

        <span class="c1"># Draw line plots</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="c1"># Make graph</span>
            <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span></div>


<div class="viewcode-block" id="SOMPlots.plt_pie">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_pie">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_pie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate pie plot for each neuron.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: Array or sequence of vectors.</span>
<span class="sd">                The wedge size</span>
<span class="sd">            s: 1-D array-like, optional</span>
<span class="sd">                Scale the size of the pie chart according to the percent of the specific class in that cell. (0-100)</span>
<span class="sd">                (default: None)</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, h_axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate the length of x (array or sequence of vectors)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of x must be equal to the number of neurons.&quot;</span><span class="p">)</span>

        <span class="c1"># Validate perc values</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Percentage values must be between 0 and 100.&quot;</span><span class="p">)</span>

        <span class="c1"># Validate the length of perc</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of s must be equal to the number of neurons.&quot;</span><span class="p">)</span>

        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Determine the number of colors needed</span>
        <span class="n">shapclust</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">num_colors</span> <span class="o">=</span> <span class="n">shapclust</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Generate a color list using a colormap</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;plasma&#39;</span><span class="p">,</span> <span class="n">num_colors</span><span class="p">)</span>  <span class="c1"># Use any suitable</span>
        <span class="n">clrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmap</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_colors</span><span class="p">)]</span>

        <span class="c1"># Setup figure, main axes, and sub-axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_axes</span><span class="p">()</span>

        <span class="c1"># Draw pie plot in each neuron</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="c1"># Determine the scale of the pie chart</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># Ensure minimum scale</span>

            <span class="c1"># Make pie chart</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">colors</span><span class="o">=</span><span class="n">clrs</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span></div>


<div class="viewcode-block" id="SOMPlots.plt_histogram">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_histogram">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate histogram for each neuron.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: array-like</span>
<span class="sd">                The input data to be plotted in histogram</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, h_axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Setup figure, main axes, and sub-axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_axes</span><span class="p">()</span>

        <span class="c1"># Draw histogram</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Make graph</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span>

                <span class="c1"># Enable the axes for this histogram</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Show tick marks</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[])</span>

                <span class="c1"># Show only the left and bottom spines</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span></div>


<div class="viewcode-block" id="SOMPlots.plt_boxplot">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_boxplot">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_boxplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate box plot for each neuron.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: array-like</span>
<span class="sd">                The input data to be plotted in box plot</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, h_axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Setup figure, main axes, and sub-axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_axes</span><span class="p">()</span>

        <span class="c1"># Find global min and max across all neuron&#39;s data</span>
        <span class="n">global_min</span><span class="p">,</span> <span class="n">global_max</span> <span class="o">=</span> <span class="n">get_global_min_max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Make graph</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span>

                <span class="c1"># Set the same y axis limits for all subplots</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">global_min</span><span class="p">,</span> <span class="n">global_max</span><span class="p">)</span>
                <span class="c1"># h_axes[neuron].set_yticks(np.linspace(global_min, global_max, 5))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span></div>


<div class="viewcode-block" id="SOMPlots.plt_violin_plot">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_violin_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_violin_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate violin plot for each neuron.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: array-like</span>
<span class="sd">                The input data to be plotted in violin plot</span>
<span class="sd">            mouse_click: bool</span>
<span class="sd">                If true, the interactive plot and sub-clustering functionalities to be activated</span>
<span class="sd">            connect_pick_event: bool</span>
<span class="sd">                If true, the pick event is connected to the plot</span>
<span class="sd">            kwarg: dict</span>
<span class="sd">                Additional arguments to be passed to the onpick function</span>
<span class="sd">                Possible keys include:</span>
<span class="sd">                    &#39;data&#39;, &#39;clust&#39;, &#39;target&#39;, &#39;num1&#39;, &#39;num2&#39;, &#39;cat&#39;, &#39;align&#39;, &#39;height&#39; and &#39;topn&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, h_axes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Setup figure, main axes, and sub-axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_axes</span><span class="p">()</span>

        <span class="c1"># Find global min and max across all neuron&#39;s data</span>
        <span class="n">global_min</span><span class="p">,</span> <span class="n">global_max</span> <span class="o">=</span> <span class="n">get_global_min_max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Make graph on the appropriate sub-axes</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span>

                <span class="c1"># Set the same y axis limits for all subplots</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">global_min</span><span class="p">,</span> <span class="n">global_max</span><span class="p">)</span>
                <span class="c1"># h_axes[neuron].set_yticks(np.linspace(global_min, global_max, 5))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span></div>


<div class="viewcode-block" id="SOMPlots.plt_scatter">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plt_scatter">[docs]</a>
    <span class="k">def</span> <span class="nf">plt_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reg_line</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generate Scatter Plot for Each Neuron.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: input data</span>
<span class="sd">            indices: array-like indices e.g. (0, 1) or [0, 1]</span>
<span class="sd">            clust: list of indices of input data for each cluster</span>
<span class="sd">            reg_line: Flag</span>

<span class="sd">        Returns:</span>
<span class="sd">            fig, ax, h_axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>

        <span class="c1"># Setup figure, main axes, and sub-axes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_axes</span><span class="p">()</span>

        <span class="c1"># Determine the global minimum and maximum of x and y for the axes limits</span>
        <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">get_global_min_max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">get_global_min_max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Loop over each neuron for hexagons and scatter plots</span>
        <span class="k">for</span> <span class="n">neuron</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="c1"># Make Scatter Plot for each neuron</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">neuron</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">reg_line</span><span class="p">:</span>
                    <span class="n">m</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">],</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Set the same x and y limits for each sub-plot based on global min and max</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>

                <span class="c1"># Show only the left and bottom spines</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Enable the axes and show tick marks</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">h_axes</span><span class="p">[</span><span class="n">neuron</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span>
                <span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h_axes</span></div>


<div class="viewcode-block" id="SOMPlots.component_positions">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.component_positions">[docs]</a>
    <span class="k">def</span> <span class="nf">component_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the SOM weight vectors, the Iris dataset input vectors, and connects neighboring neurons.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - som: A trained SOM instance with attributes &#39;w&#39; for weight vectors and &#39;dimensions&#39; for grid dimensions.</span>
<span class="sd">        - X_scaled: The normalized Iris dataset input vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Extract the trained weight vectors and the SOM grid dimensions</span>
        <span class="n">weight_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>

        <span class="c1"># Plot the SOM weight vectors as gray dots</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">weight_vectors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">weight_vectors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Weight Vectors&#39;</span><span class="p">)</span>
        <span class="c1"># for i, vec in enumerate(weight_vectors):</span>
        <span class="c1">#     plt.annotate(str(i), (vec[0], vec[1]), textcoords=&quot;offset points&quot;, xytext=(0,5), ha=&#39;center&#39;)</span>

        <span class="c1"># Plot the Iris data points as blue dots</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Input Vectors&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Draw red lines to connect neighboring neurons</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid_x</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid_y</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">grid_y</span> <span class="o">+</span> <span class="n">j</span>  <span class="c1"># Calculate the linear index of the neuron in the SOM</span>
                <span class="n">neuron</span> <span class="o">=</span> <span class="n">weight_vectors</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

                <span class="c1"># Connect to the right neighbor if it exists</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">grid_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">right_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">grid_y</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">right_neighbor</span> <span class="o">=</span> <span class="n">weight_vectors</span><span class="p">[</span><span class="n">right_index</span><span class="p">]</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">neuron</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">neuron</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">right_neighbor</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

                <span class="c1"># Connect to the bottom neighbor if it exists</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">grid_x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">bottom_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">grid_y</span> <span class="o">+</span> <span class="n">j</span>
                    <span class="n">bottom_neighbor</span> <span class="o">=</span> <span class="n">weight_vectors</span><span class="p">[</span><span class="n">bottom_index</span><span class="p">]</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">neuron</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bottom_neighbor</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">neuron</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bottom_neighbor</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>

        <span class="c1"># Set labels and legend</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Weight 1&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Weight 2&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;SOM Weight Positions&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.component_planes">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.component_planes">[docs]</a>
    <span class="k">def</span> <span class="nf">component_planes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span>
        <span class="n">shapex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">shapey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">num_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">grid_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_features</span><span class="p">)))</span>  <span class="c1"># Calculate grid size</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_features</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapey</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

                <span class="c1"># Get the weights for the current feature</span>
                <span class="n">feature_weights</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

                <span class="c1"># Normalize the weights to range between 0 and 1</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">feature_weights</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">feature_weights</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
                    <span class="n">color</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">feature_weights</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>  <span class="c1"># Choose colormap as viridis</span>
                    <span class="n">inverted_color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">color</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>  <span class="c1"># Invert the color to make darker colors represent larger weights</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="n">inverted_color</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">))</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.weight_as_image">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.weight_as_image">[docs]</a>
    <span class="k">def</span> <span class="nf">weight_as_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mouse_click</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>  <span class="c1"># Weight matrix</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>  <span class="c1"># Positions of the neurons</span>
        <span class="n">numNeurons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span>  <span class="c1"># Number of neurons</span>

        <span class="c1"># Get the shape of a single hexagon</span>
        <span class="n">shapex</span><span class="p">,</span> <span class="n">shapey</span> <span class="o">=</span> <span class="n">get_hexagon_shape</span><span class="p">()</span>

        <span class="c1"># Create the figure and axis with a larger size to accommodate the decorations</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

        <span class="c1"># Set the aspect of the plot to be equal</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="c1"># List to keep track of the hexagon patches</span>
        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numNeurons</span><span class="p">):</span>
            <span class="n">hex_center_x</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>  <span class="c1"># x coordinate of the ith position</span>
            <span class="n">hex_center_y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>  <span class="c1"># y coordinate of the ith position</span>

            <span class="c1"># Draw the hexagon</span>
            <span class="n">temp</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">hex_center_x</span> <span class="o">+</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">hex_center_y</span> <span class="o">+</span> <span class="n">shapey</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">picker</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

            <span class="c1"># Assign the cluster number for each hexagon</span>
            <span class="n">hexagon_to_neuron</span> <span class="o">=</span> <span class="p">{</span><span class="nb">hex</span><span class="p">:</span> <span class="n">neuron</span> <span class="k">for</span> <span class="n">neuron</span><span class="p">,</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">patches</span><span class="p">)}</span>

            <span class="c1"># Transform the row of weights into a matrix if necessary</span>
            <span class="n">weight_matrix</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># Assuming square matrix for simplicity</span>

            <span class="c1"># Calculate the size and position for the imshow plot</span>
            <span class="c1"># Find the radius of the hexagon, accounting for the scaling of the shape</span>
            <span class="n">hex_radius</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">shapex</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">shapex</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="c1"># Calculate the side length of the hexagon for a regular hexagon</span>
            <span class="n">side_length</span> <span class="o">=</span> <span class="n">hex_radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="c1"># Offset the inset_axes to be centered within the hexagon</span>
            <span class="c1"># The factor of sqrt(3)/2 is because in a regular hexagon, the distance from the center to a side is sqrt(3)/2 times the side length</span>
            <span class="n">axins</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">inset_axes</span><span class="p">([</span><span class="n">hex_center_x</span> <span class="o">-</span> <span class="n">side_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                   <span class="n">hex_center_y</span> <span class="o">-</span> <span class="n">side_length</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                   <span class="n">side_length</span><span class="p">,</span>
                                   <span class="n">side_length</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">)</span>

            <span class="c1"># Ensure the imshow plot takes up the correct amount of space</span>
            <span class="c1"># Adjust aspect ratio if necessary, depending on the weight matrix shape</span>
            <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">weight_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">weight_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">axins</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
            <span class="n">axins</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect_ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">side_length</span> <span class="o">/</span> <span class="p">(</span><span class="n">side_length</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))))</span>

            <span class="c1"># Turn off the axis</span>
            <span class="n">axins</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="c1"># Connect the pick event for interactivity if required</span>
        <span class="k">if</span> <span class="n">mouse_click</span> <span class="ow">and</span> <span class="n">connect_pick_event</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;pick_event&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">event</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span><span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Adjust the layout to fit everything</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="c1"># Display the plot</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Return the figure components</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span></div>


    <span class="c1"># Generic Plot Function</span>
<div class="viewcode-block" id="SOMPlots.plot">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_type</span><span class="p">,</span> <span class="n">data_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_add_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Generic Plot Function.</span>
<span class="sd">        It generates a plot based on the plot type and data provides.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        plot_type : str</span>
<span class="sd">            The type of plot to be generated:</span>
<span class="sd">            [&quot;top&quot;, &quot;top_num&quot;, &quot;hit_hist&quot;, &quot;gray_hist&quot;,</span>
<span class="sd">            &quot;color_hist&quot;, &quot;complex_hist&quot;, &quot;nc&quot;, &quot;neuron_dist&quot;,</span>
<span class="sd">            &quot;simple_grid&quot;, &quot;stem&quot;, &quot;pie&quot;, &quot;wgts&quot;, &quot;pie&quot;, &quot;hist&quot;,</span>
<span class="sd">            &quot;box&quot;, &quot;violin&quot;, &quot;scatter&quot;, &quot;component_positions&quot;,</span>
<span class="sd">            &quot;component_planes&quot;]</span>

<span class="sd">        data_dict: dict (optional)</span>
<span class="sd">            A dictionary containing the data to be plotted.</span>
<span class="sd">            The key is prefixed with the data type and the value is the data itself.</span>
<span class="sd">            {&quot;data&quot;, &quot;target&quot;, &quot;clust&quot;, &quot;add_1d_array&quot;, &quot;add_2d_array&quot;}</span>

<span class="sd">        ind : int, str or array-like (optional)</span>
<span class="sd">            The indices of the data to be plotted.</span>

<span class="sd">        target_class: int (optional)</span>
<span class="sd">            The target class to be plotted.</span>

<span class="sd">        use_add_array: bool (optional)</span>
<span class="sd">            If true, the additional array to be used.</span>

<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments to be passed to the interactive plot function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Plot Types allowed</span>
        <span class="n">plot_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;top_num&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;hit_hist&quot;</span><span class="p">,</span> <span class="s2">&quot;gray_hist&quot;</span><span class="p">,</span> <span class="s2">&quot;color_hist&quot;</span><span class="p">,</span> <span class="s2">&quot;complex_hist&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;neuron_connection&quot;</span><span class="p">,</span> <span class="s2">&quot;neuron_dist&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;simple_grid&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;stem&quot;</span><span class="p">,</span> <span class="s2">&quot;pie&quot;</span><span class="p">,</span> <span class="s2">&quot;wgts&quot;</span><span class="p">,</span> <span class="s2">&quot;hist&quot;</span><span class="p">,</span> <span class="s2">&quot;box&quot;</span><span class="p">,</span> <span class="s2">&quot;violin&quot;</span><span class="p">,</span> <span class="s2">&quot;scatter&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;component_positions&quot;</span><span class="p">,</span> <span class="s2">&quot;component_planes&quot;</span><span class="p">]</span>

        <span class="c1"># Validate the plot type</span>
        <span class="k">if</span> <span class="n">plot_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">plot_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid plot type: </span><span class="si">{</span><span class="n">plot_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Validate the data_dict</span>
        <span class="k">if</span> <span class="n">data_dict</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">plot_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;top_num&quot;</span><span class="p">,</span>
                                                   <span class="s2">&quot;neuron_connection&quot;</span><span class="p">,</span>
                                                   <span class="s2">&quot;neuron_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;wgts&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data_dict is required for this plot type.&quot;</span><span class="p">)</span>

        <span class="c1"># Validate the plot function</span>
        <span class="n">plot_functions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;top&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_top</span><span class="p">,</span>
            <span class="s2">&quot;top_num&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_top_num</span><span class="p">,</span>
            <span class="s2">&quot;hit_hist&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hit_hist</span><span class="p">,</span>
            <span class="s2">&quot;gray_hist&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gray_hist</span><span class="p">,</span>
            <span class="s2">&quot;color_hist&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_hist</span><span class="p">,</span>
            <span class="s2">&quot;complex_hist&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_cmplx_hit_hist</span><span class="p">,</span>
            <span class="s2">&quot;neuron_connection&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_nc</span><span class="p">,</span>
            <span class="s2">&quot;neuron_dist&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_dist_plot</span><span class="p">,</span>
            <span class="s2">&quot;simple_grid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">simple_grid</span><span class="p">,</span>
            <span class="s2">&quot;stem&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_stem</span><span class="p">,</span>
            <span class="s2">&quot;pie&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_pie</span><span class="p">,</span>
            <span class="s2">&quot;wgts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_wgts</span><span class="p">,</span>
            <span class="s2">&quot;hist&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_histogram</span><span class="p">,</span>
            <span class="s2">&quot;box&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_boxplot</span><span class="p">,</span>
            <span class="s2">&quot;violin&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_violin_plot</span><span class="p">,</span>
            <span class="s2">&quot;scatter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">plt_scatter</span><span class="p">,</span>
            <span class="s2">&quot;component_positions&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_positions</span><span class="p">,</span>
            <span class="s2">&quot;component_planes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">component_planes</span>
        <span class="p">}</span>

        <span class="c1"># Assign the plot function</span>
        <span class="n">selected_plot</span> <span class="o">=</span> <span class="n">plot_functions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">plot_type</span><span class="p">)</span>

        <span class="c1"># Error Handling if the plot function recieve the appropriate arguments</span>
        <span class="k">def</span> <span class="nf">validate_data_dict</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> is required for this plot type.&quot;</span><span class="p">)</span>

        <span class="c1"># ======== Topology, Neuron Connection, Neuron Distance, and Weight Plot ==========</span>
        <span class="k">if</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;top_num&quot;</span><span class="p">,</span> <span class="s2">&quot;neuron_connection&quot;</span><span class="p">,</span> <span class="s2">&quot;neuron_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;wgts&quot;</span><span class="p">]:</span>
            <span class="c1"># Call the plot function</span>
            <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># ======== Components Plane Family ==========</span>
        <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;component_positions&#39;</span><span class="p">,</span> <span class="s1">&#39;component_planes&#39;</span><span class="p">]:</span>
            <span class="c1"># Error Handling if the data_dict have the scaled input data X</span>
            <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
            <span class="c1"># Data Preparation</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_func</span><span class="p">)</span>
            <span class="c1"># Invoke Function</span>
            <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># =====================  Hit Histogram Family =====================</span>
        <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hit_hist&#39;</span><span class="p">,</span> <span class="s1">&#39;gray_hist&#39;</span><span class="p">,</span> <span class="s1">&#39;color_hist&#39;</span><span class="p">,</span> <span class="s1">&#39;complex_hist&#39;</span><span class="p">]:</span>
            <span class="c1"># Validate the data_dict have the scaled input data</span>
            <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>

            <span class="c1"># Extract input data</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hit_hist&#39;</span><span class="p">]:</span>
                <span class="c1"># Invoke the function</span>
                <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gray_hist&#39;</span><span class="p">]:</span>
                <span class="c1"># Gray Hist with add_1d_array</span>
                <span class="k">if</span> <span class="n">use_add_array</span><span class="p">:</span>
                    <span class="c1"># Validate the data_dict have the additional 1D array</span>
                    <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;add_1d_array&quot;</span><span class="p">])</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;add_1d_array&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The additional 1D array must have the same length as the clust data or original data.&quot;</span><span class="p">)</span>

                    <span class="n">perc</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;add_1d_array&#39;</span><span class="p">]</span>

                <span class="c1"># Gray hist with data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Error Handling if the target data not provided</span>
                    <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;clust&quot;</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">target_class</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This plot requires either the target class or ind.&quot;</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">target_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This plot requires only either the target class or ind.&quot;</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">target_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">validate_data_dict</span><span class="p">([</span><span class="s1">&#39;target&#39;</span><span class="p">])</span>
                        <span class="n">perc</span> <span class="o">=</span> <span class="n">get_perc_cluster</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="n">target_class</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">])</span>

                    <span class="k">elif</span> <span class="n">ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">feature</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
                        <span class="n">perc</span> <span class="o">=</span> <span class="n">get_cluster_avg</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">])</span>

                <span class="c1"># Invoke the gray hist function</span>
                <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">perc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;color_hist&#39;</span><span class="p">]:</span>
                <span class="c1"># Color Hist with additional data</span>
                <span class="k">if</span> <span class="n">use_add_array</span><span class="p">:</span>
                    <span class="n">validate_data_dict</span><span class="p">([</span><span class="s1">&#39;add_1d_array&#39;</span><span class="p">])</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;add_1d_array&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The additional 1D array must have the same length as the clust data or original data.&quot;</span><span class="p">)</span>

                    <span class="n">avg</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;add_1d_array&#39;</span><span class="p">]</span>
                <span class="c1"># Color Hist with input data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;clust&quot;</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">target_class</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This plot requires either the target class or ind.&quot;</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">target_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This plot requires only either the target class or ind.&quot;</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">target_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">validate_data_dict</span><span class="p">([</span><span class="s1">&#39;target&#39;</span><span class="p">])</span>
                        <span class="n">avg</span> <span class="o">=</span> <span class="n">get_perc_cluster</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="n">target_class</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">])</span>

                    <span class="k">elif</span> <span class="n">ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">feature</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
                        <span class="n">avg</span> <span class="o">=</span> <span class="n">get_cluster_avg</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">])</span>

                <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;complex_hist&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">use_add_array</span><span class="p">:</span>
                    <span class="c1"># Validate the data_dict have the additional 2D array</span>
                    <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;add_2d_array&quot;</span><span class="p">])</span>

                    <span class="n">add_2d_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;add_2d_array&#39;</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">add_2d_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The additional 2D array must have the same length as the number of neurons.&quot;</span><span class="p">)</span>

                    <span class="c1"># Assuming add_2d_array is a list of lists</span>
                    <span class="k">if</span> <span class="n">add_2d_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each inner list in the additional 2D array must have exactly 3 items. </span><span class="se">\</span>
<span class="s2">                        E.g. [numNeurons, [face_labels, edge_labels, edge_widths[0-20]]&quot;</span><span class="p">)</span>

                    <span class="c1"># Extract Data</span>
                    <span class="n">face_labels</span> <span class="o">=</span> <span class="n">add_2d_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">add_2d_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">edge_widths</span> <span class="o">=</span> <span class="n">add_2d_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This plot requires an additional 2-D array in data_dict. &quot;</span>
                                     <span class="s2">&quot;The additional 2D array must have 3 features. &quot;</span>
                                     <span class="s2">&quot;E.g. [numNeurons, [face_labels, edge_labels, edge_widths[0-20]]&quot;</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">face_labels</span><span class="p">,</span> <span class="n">edge_labels</span><span class="p">,</span> <span class="n">edge_widths</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># ===================== Simple Grid =====================</span>
        <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;simple_grid&#39;</span><span class="p">]:</span>
            <span class="c1"># Validate the data_dict have the original data</span>
            <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
            <span class="c1"># Simple grid with addtional variable</span>
            <span class="k">if</span> <span class="n">use_add_array</span><span class="p">:</span>
                <span class="c1"># Error Handlig if the additional 2D arrays not privided</span>
                <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;add_2d_array&quot;</span><span class="p">])</span>
                <span class="n">add_2d_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;add_2d_array&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="c1"># Validate Length</span>
                <span class="k">if</span> <span class="n">add_2d_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The additional 2D array must have the same length as the number of cluster&quot;</span><span class="p">)</span>
                <span class="c1"># Validate number of items in each cluster</span>
                <span class="k">if</span> <span class="n">add_2d_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each cluster must have only 2 items in the additional 2D array&quot;</span><span class="p">)</span>

                <span class="n">avg</span> <span class="o">=</span> <span class="n">add_2d_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">sizes</span> <span class="o">=</span> <span class="n">add_2d_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Error Handling if the target and clust data not provided</span>
                <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;clust&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The indices is required for this plot type.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">target_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The target class is required&quot;</span><span class="p">)</span>

                <span class="n">clust</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">]</span>

                <span class="c1"># Extract avg from the original data</span>
                <span class="n">num_feature</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
                <span class="n">avg</span> <span class="o">=</span> <span class="n">get_cluster_avg</span><span class="p">(</span><span class="n">num_feature</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>

                <span class="c1"># Extract size from the target</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>
                <span class="n">sizes</span> <span class="o">=</span> <span class="n">get_perc_cluster</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">target_class</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># ===================== Basic Plot Family =====================</span>
        <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;stem&#39;</span><span class="p">,</span> <span class="s1">&#39;pie&#39;</span><span class="p">]:</span>

            <span class="c1"># If the user want to plot addtional data</span>
            <span class="k">if</span> <span class="n">use_add_array</span><span class="p">:</span>
                <span class="c1"># Error Handling if the additional 2D array not provided</span>
                <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;add_2d_array&quot;</span><span class="p">])</span>

                <span class="c1"># Error Handling if additional vategorical variable has correct length</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;add_2d_array&quot;</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numNeurons</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The additional categorical data must have the same length as the clust data.&quot;</span><span class="p">)</span>

                <span class="c1">#  Get Additional Data</span>
                <span class="n">sizes</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;add_2d_array&#39;</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Error Handling if the clust data not provided</span>
                <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;clust&quot;</span><span class="p">])</span>

                <span class="c1"># Extract Information</span>
                <span class="n">clust</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">]</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>

                <span class="n">sizes</span> <span class="o">=</span> <span class="n">count_classes_in_cluster</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;pie&#39;</span><span class="p">:</span>

                <span class="c1"># =============================================</span>
                <span class="c1"># It needs to handle scale (need to implement)</span>
                <span class="c1"># =============================================</span>

                <span class="c1"># Call the pie plot</span>
                <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">plot_type</span> <span class="o">==</span> <span class="s1">&#39;stem&#39;</span><span class="p">:</span>
                <span class="c1"># Extract Align</span>
                <span class="k">if</span> <span class="n">use_add_array</span><span class="p">:</span>
                    <span class="n">align</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">align</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">target</span><span class="p">)))]</span>
                <span class="c1"># Call the stem plot</span>
                <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]:</span>
            <span class="c1"># Error Handling if the index not provided</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The indices is required for this plot type.&quot;</span><span class="p">)</span>

            <span class="c1"># Error Handling if the original data not provided</span>
            <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;clust&quot;</span><span class="p">])</span>

            <span class="c1"># Extract the feature from the original data</span>
            <span class="n">clust</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">]</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][:,</span> <span class="n">ind</span><span class="p">]</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">get_cluster_array</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scatter&#39;</span><span class="p">]:</span>
            <span class="c1"># Error Handling if the index not provided</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The indices is required for this plot type.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The indices must contain exactly two elements. Eg. [0, 1]&quot;</span><span class="p">)</span>

            <span class="c1"># Error Handling if the original data and clust not provided</span>
            <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;clust&quot;</span><span class="p">])</span>

            <span class="c1"># Extract the feature from the original data</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][:,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][:,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">clust</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">get_cluster_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">get_cluster_array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>

            <span class="c1"># Call the scatter plot function</span>
            <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">plot_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;box&#39;</span><span class="p">,</span> <span class="s1">&#39;violin&#39;</span><span class="p">]:</span>
            <span class="c1"># Error Handling if the original data not provided</span>
            <span class="n">validate_data_dict</span><span class="p">([</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;clust&quot;</span><span class="p">])</span>

            <span class="c1"># Extract the feature from the original data</span>
            <span class="n">clust</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Extract All data</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">get_cluster_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># index just have 1 index</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][:,</span> <span class="n">ind</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">get_cluster_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>  <span class="c1"># index have multiple indices</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][:,</span> <span class="n">ind</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">get_cluster_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>

            <span class="c1"># Call the box plot and violin function</span>
            <span class="k">return</span> <span class="n">selected_plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1"># Interactive Functionality</span>
<div class="viewcode-block" id="SOMPlots.onpick">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.onpick">[docs]</a>
    <span class="k">def</span> <span class="nf">onpick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">hexagons</span><span class="p">,</span> <span class="n">hexagon_to_neuron</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interactive Plot Function</span>
<span class="sd">        Args:</span>
<span class="sd">            event: event</span>
<span class="sd">                a mouse click event</span>
<span class="sd">            hexagons: list</span>
<span class="sd">                a list of hexagons</span>
<span class="sd">            hexagon_to_neuron: dict</span>
<span class="sd">                a dictionary mapping hexagons to neurons</span>
<span class="sd">            **kwargs:</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">artist</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hexagons</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Detect the clicked hexagon</span>
        <span class="n">thishex</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">artist</span>
        <span class="n">neuron_ind</span> <span class="o">=</span> <span class="n">hexagon_to_neuron</span><span class="p">[</span><span class="n">thishex</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;clust&quot;</span><span class="p">][</span><span class="n">neuron_ind</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No data in this cluster&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Create a new window</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="c1"># Button Configuration</span>
        <span class="n">button_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_button_types</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">buttons</span> <span class="o">=</span> <span class="n">create_buttons</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">button_types</span><span class="p">)</span>

        <span class="c1"># Set up button click events</span>
        <span class="k">for</span> <span class="n">button_type</span><span class="p">,</span> <span class="n">button</span> <span class="ow">in</span> <span class="n">buttons</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">button</span><span class="o">.</span><span class="n">on_clicked</span><span class="p">(</span><span class="k">lambda</span> <span class="n">event</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">button_type</span><span class="p">:</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">button_click_event</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">neuron_ind</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.button_click_event">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.button_click_event">[docs]</a>
    <span class="k">def</span> <span class="nf">button_click_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">button_type</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">neuron_ind</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Handle button click event by calling the appropriate plot function</span>
        <span class="k">if</span> <span class="n">button_type</span> <span class="o">==</span> <span class="s1">&#39;pie&#39;</span><span class="p">:</span>
            <span class="c1"># Pre-process categorical variables</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cat&#39;</span><span class="p">]</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="n">neuron_ind</span><span class="p">][:</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;topn&#39;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_pie</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">neuron_ind</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">button_type</span> <span class="o">==</span> <span class="s1">&#39;stem&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_stem</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;align&#39;</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">],</span> <span class="n">neuron_ind</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">button_type</span> <span class="o">==</span> <span class="s1">&#39;hist&#39;</span><span class="p">:</span>
            <span class="n">num1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;num1&#39;</span><span class="p">][</span><span class="n">neuron_ind</span><span class="p">][:</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;topn&#39;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_hist</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">num1</span><span class="p">,</span> <span class="n">neuron_ind</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">button_type</span> <span class="o">==</span> <span class="s1">&#39;box&#39;</span><span class="p">:</span>
            <span class="c1"># Pre-process continuous variables</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">):</span>
                    <span class="n">nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">neuron_ind</span><span class="p">][:</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;topn&#39;</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_box</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">neuron_ind</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">button_type</span> <span class="o">==</span> <span class="s1">&#39;violin&#39;</span><span class="p">:</span>
            <span class="c1"># Pre-process continuous variables</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">):</span>
                    <span class="n">nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">neuron_ind</span><span class="p">][:</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;topn&#39;</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_violin</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">neuron_ind</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">button_type</span> <span class="o">==</span> <span class="s1">&#39;scatter&#39;</span><span class="p">:</span>
            <span class="c1"># Pre-process continuous variables</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">):</span>
                    <span class="n">nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">neuron_ind</span><span class="p">][:</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;topn&#39;</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_scatter</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">neuron_ind</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">button_type</span> <span class="o">==</span> <span class="s1">&#39;sub_cluster&#39;</span><span class="p">:</span>
            <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">get_cluster_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;input_data&#39;</span><span class="p">]),</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;clust&#39;</span><span class="p">])</span>
            <span class="n">sub_clust_data</span> <span class="o">=</span> <span class="n">cluster_data</span><span class="p">[</span><span class="n">neuron_ind</span><span class="p">]</span>  <span class="c1"># Get the data for the</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sub_clustering</span><span class="p">(</span><span class="n">sub_clust_data</span><span class="p">,</span> <span class="n">neuron_ind</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown button type: </span><span class="si">{</span><span class="n">button_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SOMPlots.determine_button_types">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.determine_button_types">[docs]</a>
    <span class="k">def</span> <span class="nf">determine_button_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">button_types</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Check for categorical data for pie charts</span>
        <span class="k">if</span> <span class="s1">&#39;cat&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cat&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">button_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pie&#39;</span><span class="p">)</span>

        <span class="c1"># Check for alignment and height data for stem plots</span>
        <span class="k">if</span> <span class="s1">&#39;align&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s1">&#39;height&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">button_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;stem&#39;</span><span class="p">)</span>

        <span class="c1"># Check for numerical data and decide which buttons to add</span>
        <span class="n">num_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span>
                    <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">num_keys</span><span class="p">:</span>
            <span class="n">button_types</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;hist&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">,</span> <span class="s1">&#39;violin&#39;</span><span class="p">])</span>

            <span class="c1"># Add &#39;scatter&#39; button only if there are at least two numerical columns</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_keys</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">button_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;scatter&#39;</span><span class="p">)</span>

        <span class="c1"># Assuming sub-clustering is always an option</span>
        <span class="k">if</span> <span class="s1">&#39;input_data&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">button_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;sub_cluster&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">button_types</span></div>


    <span class="c1"># Helper function to create charts</span>
<div class="viewcode-block" id="SOMPlots.plot_pie">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plot_pie">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_pie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">neuronNum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to plot pie chart in the interactive plots</span>
<span class="sd">        Args:</span>
<span class="sd">            ax:</span>
<span class="sd">            data:</span>
<span class="sd">            neuronNum:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clear the axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># Pie chart plot logic here</span>
        <span class="c1"># Determine the number of colors needed</span>
        <span class="n">num_colors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;plasma&#39;</span><span class="p">,</span> <span class="n">num_colors</span><span class="p">)</span>
        <span class="n">clrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmap</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_colors</span><span class="p">)]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pie</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">clrs</span><span class="p">,</span> <span class="n">autopct</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%1.1f%%</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Pie Chart inside the Cluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuronNum</span><span class="p">))</span>
        <span class="c1"># Redraw the figure</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.plot_stem">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plot_stem">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">neuronNum</span><span class="p">):</span>
        <span class="c1"># Clear the axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># Stem plot</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">neuronNum</span><span class="p">])</span>  <span class="c1"># x: cat, y: data</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stem Plot inside the Clluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuronNum</span><span class="p">))</span>
        <span class="c1"># Redraw the figure</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.plot_hist">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plot_hist">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">neuronNum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to plot histogram in the interactive plots</span>
<span class="sd">        Args:</span>
<span class="sd">            ax:</span>
<span class="sd">            data:</span>
<span class="sd">            neuronNum:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clear the axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># Histogram plot logic here</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Histogram inside the Cluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuronNum</span><span class="p">))</span>
        <span class="c1"># Redraw the figure</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.plot_box">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plot_box">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">neuronNum</span><span class="p">):</span>
        <span class="c1"># Clear the axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># Box plot logic here</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Box plot in the Cluster &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuronNum</span><span class="p">))</span>
        <span class="c1"># Redraw the figure</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.plot_violin">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plot_violin">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_violin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">neuronNum</span><span class="p">):</span>
        <span class="c1"># Clear the axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># Violin plot logic here</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">violinplot</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Violin Plot inside the Cluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuronNum</span><span class="p">))</span>
        <span class="c1"># Redraw the figure</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.plot_scatter">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.plot_scatter">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">,</span> <span class="n">neuronNum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to display scatter plot in the interactive plots</span>
<span class="sd">        Args:</span>
<span class="sd">            ax:</span>
<span class="sd">            data:</span>
<span class="sd">            num1:</span>
<span class="sd">            num2:</span>
<span class="sd">            neuronNum:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clear the axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># Scatter plot logic here</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Scatter Plot inside the Cluster &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">neuronNum</span><span class="p">))</span>
        <span class="c1"># Redraw the figure</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw_idle</span><span class="p">()</span></div>


<div class="viewcode-block" id="SOMPlots.sub_clustering">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.plots.SOMPlots.sub_clustering">[docs]</a>
    <span class="k">def</span> <span class="nf">sub_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">neuron_ind</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function for interactive function which create the sub-cluster</span>
<span class="sd">        Args:</span>
<span class="sd">            data:</span>
<span class="sd">            neuron_ind:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There is no enough data to create sub-cluster&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Data Prep</span>
        <span class="n">sub_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">neuron_ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_som</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sub clustering already done&#39;</span><span class="p">)</span>
            <span class="n">sub_clust</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_som</span><span class="p">[</span><span class="n">neuron_ind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Training Sub Cluster</span>
            <span class="n">sub_clust</span> <span class="o">=</span> <span class="n">SOMPlots</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">sub_clust</span><span class="o">.</span><span class="n">init_w</span><span class="p">(</span><span class="n">sub_x</span><span class="p">)</span>
            <span class="n">sub_clust</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">sub_x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">sub_som</span><span class="p">[</span><span class="n">neuron_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_clust</span>

        <span class="c1"># Plot the sub cluster &lt;- Can we h</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">patches</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="n">sub_clust</span><span class="o">.</span><span class="n">hit_hist</span><span class="p">(</span><span class="n">sub_x</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">connect_pick_event</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Lakshmi Sravya Chalapati, Ei Tanaka.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>