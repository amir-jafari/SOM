<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NNSOM.utils &mdash; NNSOM 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            NNSOM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NNSOM.html">NNSOM package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NNSOM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">NNSOM.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for NNSOM.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">matplotlib.widgets</span> <span class="kn">import</span> <span class="n">Button</span>


<div class="viewcode-block" id="preminmax">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.preminmax">[docs]</a>
<span class="k">def</span> <span class="nf">preminmax</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="c1"># Normalize the inputs to be in the range [-1, 1]</span>
    <span class="n">minp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">maxp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">equal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">minp</span><span class="p">,</span> <span class="n">maxp</span><span class="p">)</span>
    <span class="n">nequal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">equal</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">equal</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Some maximums and minimums are equal. Those inputs won&#39;&#39;t be transformed.&#39;</span><span class="p">)</span>
        <span class="n">minp0</span> <span class="o">=</span> <span class="n">minp</span><span class="o">*</span><span class="n">nequal</span> <span class="o">-</span> <span class="mi">1</span><span class="o">*</span><span class="n">equal</span>
        <span class="n">maxp0</span> <span class="o">=</span> <span class="n">maxp</span><span class="o">*</span><span class="n">nequal</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">equal</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">minp0</span> <span class="o">=</span> <span class="n">minp</span>
        <span class="n">maxp0</span> <span class="o">=</span> <span class="n">maxp</span>

    <span class="n">minp0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">minp0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">maxp0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">maxp0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pn</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">minp0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">maxp0</span><span class="o">-</span><span class="n">minp0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">pn</span><span class="p">,</span> <span class="n">minp</span><span class="p">,</span> <span class="n">maxp</span></div>



<div class="viewcode-block" id="calculate_positions">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.calculate_positions">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_positions</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
    <span class="c1"># Calculate the positions of the neurons in the SOM</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span>
    <span class="n">len1</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">center</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">dimi</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">newlen</span> <span class="o">=</span> <span class="n">len1</span> <span class="o">*</span> <span class="n">dimi</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">center</span><span class="o">*</span><span class="n">center</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dimi</span><span class="p">):</span>
                <span class="n">ishift</span> <span class="o">=</span> <span class="p">[</span><span class="n">center</span> <span class="o">*</span> <span class="p">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)]</span>
                <span class="n">doshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ishift</span><span class="o">*</span><span class="n">len1</span><span class="p">)</span>
                <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">len1</span><span class="p">)</span><span class="o">+</span><span class="n">len1</span><span class="o">*</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">len1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">doshift</span>

        <span class="n">posi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dimi</span><span class="p">))</span> <span class="o">*</span> <span class="n">offset</span>
        <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">newlen</span><span class="p">)</span> <span class="o">/</span> <span class="n">len1</span><span class="p">)</span>
        <span class="n">ind2</span> <span class="o">=</span> <span class="n">ind2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">newlen</span><span class="p">)]</span> <span class="o">=</span> <span class="n">posi</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span>

        <span class="n">len1</span> <span class="o">=</span> <span class="n">newlen</span>
        <span class="n">center</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="k">return</span> <span class="n">position</span></div>



<div class="viewcode-block" id="cart2pol">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.cart2pol">[docs]</a>
<span class="k">def</span> <span class="nf">cart2pol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="c1"># Convert cartesian coordinates to polar coordinates</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">rho</span></div>



<div class="viewcode-block" id="pol2cart">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.pol2cart">[docs]</a>
<span class="k">def</span> <span class="nf">pol2cart</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
    <span class="c1"># Convert polar coordinates to cartesian coordinates</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>



<div class="viewcode-block" id="rotate_xy">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.rotate_xy">[docs]</a>
<span class="k">def</span> <span class="nf">rotate_xy</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
    <span class="c1"># Rotate the coordinates x1, y1 by angle</span>
    <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart2pol</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">angle</span>
    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">pol2cart</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span></div>



<div class="viewcode-block" id="normalize_position">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.normalize_position">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_position</span><span class="p">(</span><span class="n">position</span><span class="p">):</span>
    <span class="c1"># Normalize the positions of the neurons to be in the range [-1, 1]</span>
    <span class="n">shap</span> <span class="o">=</span> <span class="n">position</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">numPos</span> <span class="o">=</span> <span class="n">shap</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">minPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">maxPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">difPos</span> <span class="o">=</span> <span class="n">maxPos</span> <span class="o">-</span> <span class="n">minPos</span>
    <span class="n">equal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">minPos</span><span class="p">,</span> <span class="n">maxPos</span><span class="p">)</span>
    <span class="n">difPos</span><span class="p">[</span><span class="n">equal</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">minPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">minPos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">minPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">minPos</span><span class="p">,</span> <span class="n">numPos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">difPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">difPos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">difPos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">difPos</span><span class="p">,</span> <span class="n">numPos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">posit</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">position</span> <span class="o">-</span> <span class="n">minPos</span><span class="p">)</span><span class="o">/</span><span class="n">difPos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">posit</span></div>



<div class="viewcode-block" id="spread_positions">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.spread_positions">[docs]</a>
<span class="k">def</span> <span class="nf">spread_positions</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">positionMean</span><span class="p">,</span> <span class="n">positionBasis</span><span class="p">):</span>
    <span class="c1"># Spread the positions of the neurons</span>
    <span class="n">shappos</span> <span class="o">=</span> <span class="n">position</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">numPos</span> <span class="o">=</span> <span class="n">shappos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">position1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">positionMean</span><span class="p">,</span> <span class="n">numPos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">positionBasis</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">position1</span></div>



<div class="viewcode-block" id="distances">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.distances">[docs]</a>
<span class="k">def</span> <span class="nf">distances</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
    <span class="c1"># Compute the distances between the neurons in the SOM topology</span>
    <span class="n">posT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">posT</span><span class="p">,</span> <span class="n">posT</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>

    <span class="n">link</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="mf">1.00001</span>
    <span class="n">link</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="mf">1.0</span><span class="o">*</span><span class="n">link</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">link</span><span class="p">)</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">floyd_warshall_numpy</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dist</span></div>



<div class="viewcode-block" id="get_hexagon_shape">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_hexagon_shape">[docs]</a>
<span class="k">def</span> <span class="nf">get_hexagon_shape</span><span class="p">():</span>
    <span class="c1"># Determine the shape of the hexagon to represent each cluster</span>
    <span class="n">shapex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">shapey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="k">return</span> <span class="n">shapex</span><span class="p">,</span> <span class="n">shapey</span></div>



<div class="viewcode-block" id="get_edge_shape">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_edge_shape">[docs]</a>
<span class="k">def</span> <span class="nf">get_edge_shape</span><span class="p">():</span>
    <span class="c1"># Determine the shape of the elongated hexagon to represent edge between each cluster</span>
    <span class="n">edgex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">edgey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.75</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="k">return</span> <span class="n">edgex</span><span class="p">,</span> <span class="n">edgey</span></div>



<span class="c1"># Helper Functions to extract information from the input data for passing to the plot</span>
<div class="viewcode-block" id="get_cluster_data">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_cluster_data">[docs]</a>
<span class="k">def</span> <span class="nf">get_cluster_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each cluster, extract the corresponding data points and return them in a list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy array</span>
<span class="sd">        The dataset from which to extract the clusters&#39; data.</span>
<span class="sd">    clust : list of arrays</span>
<span class="sd">        A list where each element is an array of indices for data points in the corresponding cluster.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cluster_data_list : list of numpy arrays</span>
<span class="sd">        A list where each element is a numpy array containing the data points of a cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cluster_data_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cluster_indices</span> <span class="ow">in</span> <span class="n">clust</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Ensure cluster_indices are integers and within the range of data</span>
            <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">]</span>
            <span class="n">cluster_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cluster_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>  <span class="c1"># Use an empty array for empty clusters</span>

    <span class="k">return</span> <span class="n">cluster_data_list</span></div>



<div class="viewcode-block" id="get_cluster_array">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_cluster_array">[docs]</a>
<span class="k">def</span> <span class="nf">get_cluster_array</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a NumPy array of objects, each containing the feature values for each cluster.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feature : array-like</span>
<span class="sd">        Feature array.</span>
<span class="sd">    clust : list</span>
<span class="sd">        A list of cluster arrays, each containing indices sorted by distances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cluster_array : numpy.ndarray</span>
<span class="sd">        A NumPy array where each element is an array of feature values for that cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cluster_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster_indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clust</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cluster_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cluster_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>  <span class="c1"># Store an empty array if the cluster is empty</span>

    <span class="k">return</span> <span class="n">cluster_array</span></div>



<div class="viewcode-block" id="get_cluster_avg">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_cluster_avg">[docs]</a>
<span class="k">def</span> <span class="nf">get_cluster_avg</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the average value of a feature for each cluster.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    feature : array-like</span>
<span class="sd">        Feature array.</span>
<span class="sd">    clust : list</span>
<span class="sd">        A list of cluster arrays, each containing indices sorted by distances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cluster_avg : numpy array</span>
<span class="sd">        A cluster array with the average value of the feature for each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cluster_array</span> <span class="o">=</span> <span class="n">get_cluster_array</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">clust</span><span class="p">)</span>
    <span class="n">cluster_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_array</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_array</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cluster_avg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cluster_array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">cluster_avg</span></div>



<div class="viewcode-block" id="closest_class_cluster">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.closest_class_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">closest_class_cluster</span><span class="p">(</span><span class="n">cat_feature</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cluster array with the closest class for each cluster.</span>

<span class="sd">    Paramters</span>
<span class="sd">    ----------</span>
<span class="sd">    cat_feature : array-like</span>
<span class="sd">        Categorical feature array.</span>
<span class="sd">    clust : list</span>
<span class="sd">        A cluster array of indices sorted by distances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    closest_class : numpy array</span>
<span class="sd">        A cluster array with the closest class for each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">closest_class</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)):</span>
        <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">closest_class</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat_feature</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">closest_class</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Avoid division by zero if the cluster is empty</span>

    <span class="k">return</span> <span class="n">closest_class</span></div>



<div class="viewcode-block" id="majority_class_cluster">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.majority_class_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">majority_class_cluster</span><span class="p">(</span><span class="n">cat_feature</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cluster array with the majority class for each cluster.</span>

<span class="sd">    Paramters</span>
<span class="sd">    ----------</span>
<span class="sd">    cat_feature : array-like</span>
<span class="sd">        Categorical feature array.</span>
<span class="sd">    clust : list</span>
<span class="sd">        A cluster array of indices sorted by distances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    majority_class : numpy array</span>
<span class="sd">        A cluster array with the majority class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">majority_class</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)):</span>
        <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">majority_class</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">cat_feature</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">majority_class</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Avoid division by zero if the cluster is empty</span>

    <span class="k">return</span> <span class="n">majority_class</span></div>



<div class="viewcode-block" id="get_perc_cluster">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_perc_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">get_perc_cluster</span><span class="p">(</span><span class="n">cat_feature</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return cluster array with the percentage of a specific target class in each cluster.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cat_feature : array-like</span>
<span class="sd">        Categorical feature array.</span>
<span class="sd">    target : int or str</span>
<span class="sd">        Target class to calculate the percentage.</span>
<span class="sd">    clust : list</span>
<span class="sd">        A cluster array of indices sorted by distances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cluster_array : numpy array</span>
<span class="sd">        A cluster array with the percentage of target class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create Cluster Array with the percentage of target class</span>
    <span class="n">cluster_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)):</span>
        <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cluster_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cat_feature</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cluster_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Avoid division by zero if the cluster is empty</span>

    <span class="k">return</span> <span class="n">cluster_array</span> <span class="o">*</span> <span class="mi">100</span></div>



<div class="viewcode-block" id="count_classes_in_cluster">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.count_classes_in_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">count_classes_in_cluster</span><span class="p">(</span><span class="n">cat_feature</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count the occurrences of each class in each cluster using vectorized operations</span>
<span class="sd">    for efficiency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cat_feature : array-like</span>
<span class="sd">        Categorical feature array.</span>
<span class="sd">    clust : list</span>
<span class="sd">        A list of arrays, each containing the indices of elements in a cluster.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cluster_counts : numpy array</span>
<span class="sd">        A 2D array with counts of each class in each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_classes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cat_feature</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_classes</span><span class="p">)</span>

    <span class="c1"># Initialize the array to hold class counts for each cluster</span>
    <span class="n">cluster_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">),</span> <span class="n">num_classes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Loop over clusters to count class occurrences</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clust</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Count occurrences of each class in the cluster</span>
            <span class="n">cluster_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cat_feature</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">==</span> <span class="bp">cls</span><span class="p">)</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">unique_classes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cluster_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cluster_counts</span></div>



<div class="viewcode-block" id="cal_class_cluster_intersect">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.cal_class_cluster_intersect">[docs]</a>
<span class="k">def</span> <span class="nf">cal_class_cluster_intersect</span><span class="p">(</span><span class="n">clust</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the intersection sizes of each class with each neuron cluster.</span>

<span class="sd">    This function computes the size of the intersection between each given class</span>
<span class="sd">    (represented by arrays of indices) and each neuron cluster (represented by</span>
<span class="sd">    a list of lists of indices). The result is a 2D array where each row corresponds</span>
<span class="sd">    to a neuron cluster, and each column corresponds to one of the classes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    clust : list of lists</span>
<span class="sd">        A collection of neuron clusters, where each neuron cluster is a list of indices.</span>
<span class="sd">    *args : sequence of array-like</span>
<span class="sd">        A variable number of arrays, each representing a class with indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A 2D array where the entry at position (i, j) represents the number of indices</span>
<span class="sd">        in the j-th class that are also in the i-th neuron cluster.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; clust = [[4, 5, 9], [1, 7], [2, 10, 11], [3, 6, 8]]</span>
<span class="sd">    &gt;&gt;&gt; ind1 = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ind2 = np.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; ind3 = np.array([7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; ind4 = np.array([10, 11, 12])</span>
<span class="sd">    &gt;&gt;&gt; get_sizes_clust(clust, ind1, ind2, ind3, ind4)</span>
<span class="sd">    array([[0, 2, 1, 0],</span>
<span class="sd">           [1, 0, 1, 0],</span>
<span class="sd">           [1, 0, 0, 2],</span>
<span class="sd">           [1, 1, 1, 0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="n">cluster_sizes_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">numst</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">numst</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clust</span><span class="p">):</span>
            <span class="n">cluster_sizes_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">ind</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">cluster_sizes_matrix</span><span class="o">.</span><span class="n">T</span></div>



<span class="c1"># Helper function  to extract information from the post-training model for passing to the plot</span>
<div class="viewcode-block" id="get_ind_misclassified">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_ind_misclassified">[docs]</a>
<span class="k">def</span> <span class="nf">get_ind_misclassified</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">prediction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the indices of misclassified items.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target : array-like</span>
<span class="sd">        The true target values.</span>
<span class="sd">    prediction : array-like</span>
<span class="sd">        The predicted values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    misclassified_indices : list</span>
<span class="sd">        List of indices of misclassified items.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">misclassified_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="n">prediction</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">misclassified_indices</span></div>



<div class="viewcode-block" id="get_perc_misclassified">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_perc_misclassified">[docs]</a>
<span class="k">def</span> <span class="nf">get_perc_misclassified</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">prediction</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the percentage of misclassified items in each cluster and return as a numpy array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target : array-like</span>
<span class="sd">        The true target values.</span>
<span class="sd">    prediction : array-like</span>
<span class="sd">        The predicted values.</span>
<span class="sd">    clust : array-like</span>
<span class="sd">        List of arrays, each containing the indices of elements in a cluster.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    proportion_misclassified : numpy array</span>
<span class="sd">        Percentage of misclassified items in each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the indices of misclassified items.</span>
    <span class="n">misclassified_indices</span> <span class="o">=</span> <span class="n">get_ind_misclassified</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">prediction</span><span class="p">)</span>

    <span class="c1"># Initialize array to store proportion of misclassified items</span>
    <span class="n">proportion_misclassified</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster_indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clust</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Compute intersection of cluster indices and misclassified indices</span>
            <span class="n">misclassified_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">,</span> <span class="n">misclassified_indices</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
            <span class="n">proportion_misclassified</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">misclassified_count</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span>

    <span class="k">return</span> <span class="n">proportion_misclassified</span></div>



<div class="viewcode-block" id="get_conf_indices">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_conf_indices">[docs]</a>
<span class="k">def</span> <span class="nf">get_conf_indices</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">target_class</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the indices of True Positive, True Negative, False Positive, and False Negative for a specific target class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target : array-like</span>
<span class="sd">        The true target values.</span>
<span class="sd">    results : array-like</span>
<span class="sd">        The predicted values.</span>
<span class="sd">    target_class : int</span>
<span class="sd">        The target class for which to get the confusion indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tp_index : numpy array</span>
<span class="sd">        Indices of True Positives.</span>
<span class="sd">    tn_index : numpy array</span>
<span class="sd">        Indices of True Negatives.</span>
<span class="sd">    fp_index : numpy array</span>
<span class="sd">        Indices of False Positives.</span>
<span class="sd">    fn_index : numpy array</span>
<span class="sd">        Indices of False Negatives.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tp_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">target</span> <span class="o">==</span> <span class="n">target_class</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">results</span> <span class="o">==</span> <span class="n">target_class</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tn_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">target</span> <span class="o">!=</span> <span class="n">target_class</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">results</span> <span class="o">!=</span> <span class="n">target_class</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fp_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">target</span> <span class="o">!=</span> <span class="n">target_class</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">results</span> <span class="o">==</span> <span class="n">target_class</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">fn_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">target</span> <span class="o">==</span> <span class="n">target_class</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">results</span> <span class="o">!=</span> <span class="n">target_class</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">tp_index</span><span class="p">,</span> <span class="n">tn_index</span><span class="p">,</span> <span class="n">fp_index</span><span class="p">,</span> <span class="n">fn_index</span></div>


<div class="viewcode-block" id="flatten">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.flatten">[docs]</a>
<span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively flattens a nested list structure of numbers into a single list.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: A number (int or float) or a nested list of numbers. The data to be flattened.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of numbers, where all nested structures in the input have been</span>
<span class="sd">        flattened into a single list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>  <span class="c1"># base case for numbers</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flat_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">flat_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>  <span class="c1"># recursive call to flatten</span>
        <span class="k">return</span> <span class="n">flat_list</span></div>



<div class="viewcode-block" id="get_global_min_max">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_global_min_max">[docs]</a>
<span class="k">def</span> <span class="nf">get_global_min_max</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the global minimum and maximum values in a nested list structure.</span>

<span class="sd">    This function flattens the input data into a single list and then</span>
<span class="sd">    determines the minimum and maximum values.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: A nested list of integers. The structure can be of any depth.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple (min_value, max_value) where min_value is the minimum value</span>
<span class="sd">        in the data, and max_value is the maximum value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flat_list</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">flat_list</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">flat_list</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_edge_widths">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_edge_widths">[docs]</a>
<span class="k">def</span> <span class="nf">get_edge_widths</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">clust</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Calculate edge width for each cluster based on the number of indices in the cluster.</span>

<span class="sd">    Args:</span>
<span class="sd">        indices: 1-d array</span>
<span class="sd">            Array of indices for the specific class.</span>
<span class="sd">        clust: sequence of vectors</span>
<span class="sd">            A sequence of vectors, each containing the indices of elements in a cluster.</span>

<span class="sd">    Returns:</span>
<span class="sd">        lwidth: 1-d array</span>
<span class="sd">            Array of edge widths for each cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lwidth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">lwidth</span></div>



<div class="viewcode-block" id="get_color_labels">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.get_color_labels">[docs]</a>
<span class="k">def</span> <span class="nf">get_color_labels</span><span class="p">(</span><span class="n">clust</span><span class="p">,</span> <span class="o">*</span><span class="n">listOfIndices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Generates color label for each cluster based on indices of classes.</span>

<span class="sd">    Args:</span>
<span class="sd">        clust: sequence of vectors</span>
<span class="sd">            A sequence of vectors, each containing the indices of elements in a cluster.</span>

<span class="sd">        *args: 1-d array</span>
<span class="sd">            A list of indices where the specific class is present.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate if the user have provided at least one class indices</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">listOfIndices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one class indices must be provided.&#39;</span><span class="p">)</span>

    <span class="c1"># Validate if the arg is a list or numpy array and unpack them</span>
    <span class="n">numst</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">listOfIndices</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The arguments must be a list or numpy array.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="c1"># Initialize the color label array</span>
    <span class="n">color_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">))</span>

    <span class="c1"># When there is only one list provides,</span>
    <span class="c1"># check if the cluster contains the indices of the class.</span>
    <span class="c1"># If that class is majority in the cluster, assign 1, otherwise 0.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">numst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_class</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">num_class</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">color_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">color_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Detect the intersection of the cluster and each list of indices (class),</span>
        <span class="c1"># and get the majority class in the cluster.</span>
        <span class="c1"># Append the majority class to the edge color array.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">clust</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numst</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numst</span><span class="p">))]</span>
                <span class="n">color_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">color_labels</span></div>



<span class="c1"># Helper functions to create button objects in the interactive plot</span>
<div class="viewcode-block" id="create_buttons">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.create_buttons">[docs]</a>
<span class="k">def</span> <span class="nf">create_buttons</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">button_types</span><span class="p">):</span>
    <span class="n">sidebar_width</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">button_config</span> <span class="o">=</span> <span class="n">calculate_button_positions</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">button_types</span><span class="p">),</span> <span class="n">sidebar_width</span><span class="p">)</span>

    <span class="n">buttons</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">button_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">button_types</span><span class="p">):</span>
        <span class="n">button_ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_axes</span><span class="p">(</span><span class="n">button_config</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">buttons</span><span class="p">[</span><span class="n">button_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">Button</span><span class="p">(</span><span class="n">button_ax</span><span class="p">,</span> <span class="n">button_type</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span> <span class="n">hovercolor</span><span class="o">=</span><span class="s1">&#39;0.975&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">buttons</span></div>



<div class="viewcode-block" id="calculate_button_positions">
<a class="viewcode-back" href="../../NNSOM.html#NNSOM.utils.calculate_button_positions">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_button_positions</span><span class="p">(</span><span class="n">num_buttons</span><span class="p">,</span> <span class="n">sidebar_width</span><span class="p">):</span>
    <span class="c1"># Calculate button positions and sizes</span>
    <span class="n">button_ratio</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">9</span>
    <span class="n">single_button_width</span> <span class="o">=</span> <span class="n">sidebar_width</span> <span class="o">*</span> <span class="mf">0.8</span>
    <span class="n">single_button_height</span> <span class="o">=</span> <span class="n">single_button_width</span> <span class="o">/</span> <span class="n">button_ratio</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">total_buttons_height</span> <span class="o">=</span> <span class="n">num_buttons</span> <span class="o">*</span> <span class="n">single_button_height</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_buttons</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">margin</span>

    <span class="n">button_config</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_buttons</span><span class="p">):</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">total_buttons_height</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_buttons</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">single_button_height</span> <span class="o">+</span> <span class="n">margin</span><span class="p">)</span>
        <span class="n">x_centered</span> <span class="o">=</span> <span class="mf">0.8</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.2</span> <span class="o">-</span> <span class="n">single_button_width</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">button_config</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_centered</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">single_button_width</span><span class="p">,</span> <span class="n">single_button_height</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">button_config</span></div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Lakshmi Sravya Chalapati, Ei Tanaka.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>